<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>VSCP framework: Manual of VSCP L1 Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VSCP framework
   &#160;<span id="projectnumber">v0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Manual of VSCP L1 Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h1><a class="anchor" id="pageTOC"></a>
Content</h1>
<ol type="1">
<li><a class="el" href="index.html#vscp">Very Simple Control Protocol (VSCP)</a></li>
<li><a class="el" href="index.html#framework">Framework</a></li>
<li><a class="el" href="index.html#structure">Structure</a></li>
<li><a class="el" href="index.html#getting_started">Getting started</a></li>
</ol>
<h1><a class="anchor" id="vscp"></a>
Very Simple Control Protocol (VSCP)</h1>
<div class="image">
<img src="vscp_logo.jpg" alt="vscp_logo.jpg"/>
</div>
<p>The Very Simple Control Protocol (VSCP), an open and free protocol for IoT/m2m automation tasks.</p>
<p>More information can be found on the main site <a href="http://www.vscp.org">http://www.vscp.org</a></p>
<h1><a class="anchor" id="framework"></a>
Framework</h1>
<p>The VSCP software framework for level 1 devices provides several layers according to the VSCP specification (<a href="http://www.vscp.org/docs/vscpspec/doku.php">http://www.vscp.org/docs/vscpspec/doku.php</a>).</p>
<p>More information can be found on the main site <a href="http://www.vscp.org">http://www.vscp.org</a></p>
<h2><a class="anchor" id="core"></a>
Core</h2>
<div class="image">
<img src="vscp_modules.png" alt="vscp_modules.png"/>
</div>
 <div class="image">
<img src="vscp_modules_color_legend.png" alt="vscp_modules_color_legend.png"/>
</div>
<ul>
<li>The core functionality which has a built-in state machine to handle different use cases of the protocol and etc. (<a class="el" href="group__vscp__core.html">The VSCP core functionality.</a>). Right now it supports every mandatory event and some minor optional ones.</li>
<li>The decision matrix is handled separately (<a class="el" href="group__vscp__dm.html">Decision matrix</a>). It contains the standard decision matrix, as described in the VSCP specification and contains an additional extension.</li>
<li>The decision matrix next generation is supported too (<a class="el" href="group__vscp__dm__ng.html">VSCP decision matrix next generation</a>). It eliminates the limitations of the standard decision matrix, incl. its extension.</li>
<li>VSCP needs some mandatory persistent data, which can be modified during run time. This kind of data is in the persistent storage handled (<a class="el" href="group__vscp__ps.html">Persistent memory driver</a>).</li>
<li>The device specific data is handled separatly (<a class="el" href="group__vscp__dev__data.html">VSCP device data</a>). You can decide whether this data shall be constant and configured during compile time or its loaded from persistent storage and could be modified during run time.</li>
<li>The transport layer has the possibility to loop events back (<a class="el" href="group__vscp__transport.html">Transport layer</a>). This can be configured for each data (<a class="el" href="group__vscp__dev__data__config.html">Device default data configuration</a>), except the firmware version.</li>
<li>Functionality can be configured for your needs (<a class="el" href="group__vscp__config.html">VSCP default configuration</a>).</li>
<li>Some utility functions are separated (<a class="el" href="group__vscp__util.html">VSCP utilities</a>) and used by different core modules or are maybe interested for the application too.</li>
<li>Log functionaly is provided for debugging purposes (<a class="el" href="group__vscp__logger.html">VSCP logger</a>).</li>
</ul>
<p>The framework is independent of the hardware and the used operating system. To achieve independence all of the following layers have to be adapted to the system. This is supported by templates, which contains all necessary functions with nearly empty bodys.</p>
<p>The following modules have to be adapted for your needs, because it depends on the hardware, the operating system or how VSCP is integrated into your software:</p>
<ul>
<li>Transport adapter (<a class="el" href="group__vscp__tp__adapter.html">Transport driver adapter</a>)</li>
<li>Timer driver (<a class="el" href="group__vscp__timer.html">Timer</a>)</li>
<li>Persistent memory access driver (<a class="el" href="group__vscp__ps__access.html">Persistent memory access driver</a>)</li>
<li>Action module, used by the decision matrix (standard, extension and next generation) (<a class="el" href="group__vscp__action.html">VSCP actions</a>)</li>
<li>Application register access (<a class="el" href="group__vscp__app__reg.html">VSCP application registers</a>)</li>
<li>Callout functions, lamp handling and etc. (<a class="el" href="group__vscp__portable.html">Portable stuff</a>)</li>
</ul>
<p>Templates exists for all of them, which makes it much easier to adapt it and less time. See in the templates folder.</p>
<h2><a class="anchor" id="eventAbstraction"></a>
Event abstraction</h2>
<div class="image">
<img src="vscp_event_modules.png" alt="vscp_event_modules.png"/>
</div>
<p>Using only the core, you have to assemble the VSCP events by yourself. If you want to deal only with parameter, which are VSCP independent, use the next upper layer, the event abstraction modules.</p>
<h1><a class="anchor" id="structure"></a>
Structure</h1>
<pre>
+---common              (Common sourcecode, used for examples and projects)
|   +---avr             (Common sourcecode for Atmel AVR microcontrollers)
|   \---pc              (Common sourcecode for PC)
+---examples            (Examples which are showing how to use the VSCP framework)
|   +---avr             (Examples with Atmel AVR microcontrollers)
|   \---pc              (PC example for windows and linux)
+---projects            (Projects)
|   +---avr             (Projects with Atmel AVR microcontrollers)
|   \---pc              (PC projects)
+---tools               (General tools, used by examples and projects)
|   \---xslt            (XML transformation processor)
\---vscp                (VSCP framework)
    +---doc             (Documentation)
    |   +---doxfiles    (Doxygen related files)
    |   \---html        (Doxygen generated documentation in HTML)
    +---events          (These modules are using the VSCP core to send CLASS1 dedicated events)
    +---templates       (Templates of the files, which the user shall adapt to its needs)
    \---test            (Test of the VSCP framework)
</pre><h1><a class="anchor" id="getting_started"></a>
Getting started</h1>
<p>This part shows you how to get the VSCP framework working in a "minimal" way:</p>
<ol type="1">
<li><a class="el" href="index.html#copy">Copy the VSCP framework to your project</a></li>
<li><a class="el" href="index.html#init">Initialization of the VSCP framework.</a></li>
<li><a class="el" href="index.html#process">Processing of the VSCP framework.</a></li>
<li><a class="el" href="index.html#timer">VSCP framework timer</a></li>
<li><a class="el" href="index.html#tp_adapter">VSCP transport adaption</a></li>
<li><a class="el" href="index.html#status_led">Control the VSCP lamp</a></li>
<li><a class="el" href="index.html#connect_init_button">Connect the initialization button</a></li>
<li><a class="el" href="index.html#ps_access">Persistent memory</a></li>
<li><a class="el" href="index.html#ready">Ready to run</a></li>
</ol>
<h2><a class="anchor" id="copy"></a>
Copy the VSCP framework to your project</h2>
<ol type="1">
<li>Copy or link the VSCP framework (./vscp and ./vscp/events) to your project.</li>
<li>Copy (!!do not link!!) all necessary template files (./vscp/templates) to your project. Recommended is a sub-directory "vscp_user".</li>
<li>Update your makefile or your project configuration.</li>
</ol>
<h2><a class="anchor" id="init"></a>
Initialization of the VSCP framework.</h2>
<p>The VSCP framework has to be initialized, before any function is used. This is simply done by calling the function <a class="el" href="group__vscp__core.html#ga73193ecd1562b547ab3803147aee078c" title="This function initializes VSCP, including all layers. ">vscp_core_init()</a> during start-up.</p>
<h2><a class="anchor" id="process"></a>
Processing of the VSCP framework.</h2>
<p>The VSCP framework has to be called periodically to be able to react on incoming events. Call the process routine <a class="el" href="group__vscp__core.html#ga908d6072c9422beb0f7c3987c80ab1d7" title="This function process the whole VSCP core stack. ">vscp_core_process()</a> in a constant cyclic period. The period should be lower or equal than 100 ms, but depends on several factors, like the bitrate on the choosen communication bus, the event load on the bus and etc.</p>
<p>The process routine handle all received VSCP events.</p>
<h2><a class="anchor" id="timer"></a>
VSCP framework timer</h2>
<p>VSCP specifies several timing behaviour in different use cases. Therefore the framework needs some timers to achieve it.</p>
<p>Because timer are usually hardware and software dependend, they have to be implemented by you for your needs. Adapt the <a class="el" href="vscp__timer_8c.html" title="VSCP timer layer. ">vscp_timer.c</a> template file. Find all necessary informations in the module.</p>
<p>The timer handling can be processed by calling <a class="el" href="group__vscp__timer.html#ga39737fef1987eec20f7242d04e961987" title="This function process all timers and has to be called cyclic. ">vscp_timer_process()</a> in the same or in a different task as <a class="el" href="group__vscp__core.html#ga908d6072c9422beb0f7c3987c80ab1d7" title="This function process the whole VSCP core stack. ">vscp_core_process()</a> is called. If a different task calls it, don't forget to make the timer functions reentrant!</p>
<p>Because the VSCP timer module needs to know the period of processing the timers, you have to call it with the period time in ms as parameter, e.g. vscp_timer_process(1000);</p>
<p>Call the timer processing routine equal or lower than 1 s.</p>
<p>Note, that never call vscp_process() with a lower period, than <a class="el" href="group__vscp__timer.html#ga39737fef1987eec20f7242d04e961987" title="This function process all timers and has to be called cyclic. ">vscp_timer_process()</a>. Because vscp_process() reacts on timer timeouts and <a class="el" href="group__vscp__timer.html#ga39737fef1987eec20f7242d04e961987" title="This function process all timers and has to be called cyclic. ">vscp_timer_process()</a> decrease only the timers, but doesn't do more.</p>
<h2><a class="anchor" id="tp_adapter"></a>
VSCP transport adaption</h2>
<p>Now its time to connect the VSCP framework to the communication bus. This can be done by implementing the transport adapter in the <a class="el" href="vscp__tp__adapter_8c.html" title="VSCP transport layer adapter. ">vscp_tp_adapter.c</a> template file.</p>
<h2><a class="anchor" id="status_led"></a>
Control the VSCP lamp</h2>
<p>To see that something is happen on your embedded device, next step is to control the VSCP lamp (in most cases a LED). Update the function <a class="el" href="group__vscp__portable.html#ga074bc784f7c27c9aea259a6921898c85" title="This function set the current lamp state. ">vscp_portable_setLampState()</a> in the <a class="el" href="vscp__portable_8c.html" title="VSCP portable support package. ">vscp_portable.c</a> module.</p>
<h2><a class="anchor" id="connect_init_button"></a>
Connect the initialization button</h2>
<p>According to the VSCP specification, every embedded device should have a button to start the segment initialization. Hopefully you have one right now :-) and if it is pressed, call the function <a class="el" href="group__vscp__core.html#gac37457174e4d80c9188935bea515284f" title="This function starts the node segment initialization. ">vscp_core_startNodeSegmentInit()</a> in the <a class="el" href="vscp__core_8c.html" title="VSCP core functionality. ">vscp_core.c</a> module.</p>
<h2><a class="anchor" id="ps_access"></a>
Persistent memory</h2>
<p>It is important that the VSCP framework can store data in a persistent memory, e.g. an EEPROM. Implement in the <a class="el" href="vscp__ps__access_8c.html" title="VSCP persistent memory access driver. ">vscp_ps_access.c</a> module the low level access to the persistent memory. Its quite easy, because only byte access functions are used, so you have one read and one write function to adapt.</p>
<h2><a class="anchor" id="ready"></a>
Ready to run</h2>
<p>Now the minimal sub set is done and your node hopefully starts up with a nickname discovery.</p>
<p>Have fun! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 26 2017 20:14:42 for VSCP framework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
